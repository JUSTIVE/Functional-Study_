# Can programming be liberated from the von Neumann style? A functional style and its algebra of programs

John Backus, IBM Research Laboratory

기성 프로그래밍 언어들은 비대해지고 있으나, 강해지진 않고 있다. 가장 근본적인 수준의 선천적 결함으로 인해서 비만과 약화가 일어나고 있다. 이러한 속성들은 원시적인 명령형 스타일의 프로그래밍은 그들의 공통 조상인 폰 노이만으로부터 물려받았다. 
- 상태 전환과 문법의 강한 결합
- 세상의 표현과 세상의 구문의 세계
- 프로그램들로부터 새 프로그램을 만들기 위해 효과적이게 수식을 결합하는 기능의 무능
- 프로그램 추론을 위한 유용한 수학적 속성들의 부재.

이와 다른 함수형 스타일의 프로그래밍은 프로그램을 만들기 위해 수식을 결합하는 형태로 사용한다.  
함수형 프로그래밍은 때로는 
- 반복적이지 않고
- 비재귀적인
- 위계적으로 구조화된
- 인자의 이름을 가지지 않는
- 그리고 일반적으로 사용하기 위해 절차적 선언들의 복잡한 구조화를 요구하지 않는

구조적인 데이터를 다룬다.

수식의 조합은 기성 프로그래밍 언어에서는 가능하지 않았던 고수준의 프로그램을 더 높은 수준으로 올리는 것이 가능하다. 함수형 스타일의 프로그래밍과 연관된 것은 변수들이 프로그램 전반에 걸쳐있고, 연산들이 수식을 결합하는 프로그램의 대수이다. 이 대수는 프로그램을 변환하는 데에 사용되거나, 고등학교의 대수에서와 마찬가지로 프로그램에서의 미지의 값을 구하는 데에 사용할 수도 있습니다. 이러한 변환은 대수 법칙으로부터 주어지고, 우리가 프로그램을 작성하는 것과 같은 언어로 표현된다. 수식 결합은 프로그래밍 능력 뿐만 아니라 연관 대수 법칙의 능력에 대해서도 선택된다. 대수의 일반론은 거대 규모의 프로그램의 구체적인 동작과 종료 조건들을 제시합니다. 새로은 계급의 컴퓨터 시스템들은 프로그래밍 언어와 상태 변환 규칙에 함수형 프로그래밍 스타일을 사용한다. 폰 노이만 언어들과는 다르게 이 시스템들은 상태와 느슨한 결합을 가지고 하나의 주요 연산당 하나의 상태 전환만을 야기한다.

## 1. 비대하고 연약한 기존 프로그래밍 언어
 
프로그래밍 언어들은 위험에 처해있다. 새로운 언어들은 약간의 정리를 통해 이전 언어의 모든 기능과 새로운 기능들을 통합한다. 몇몇 언어들은 500 페이지가 넘는 매뉴얼을 가지기도 한다. 다른 언어들은 더 촘촘한 형식을 이용해서 여전히 복잡한 설명들을 짧은 설명서에 집어넣기도 한다. 국방부는 위원회가 설계한 1000 페이지의 설명서를 가진 언어 표준을 계획하고 있다. 매번 새로운 언어들이 강타입이나 구조적 제어문과 같은 새롭고 화려한 기능들을 주장하지만 명백한 사실은 매우 적은 언어들만이 프로그래밍을 쉽게 하거나 배우고 사용하는 비용을 정당화하기 위해 더 안정적으로 만들 뿐이다.
규모가 커지는 것에 반해 매우 작은 성능 향상을 가져옴에 따라, 파스칼과 같이 세련된 언어들이 인기를 얻고 있다. 하지만 프로그램을 생각하는 방식을 돕는 강력한 방법론이 절실히 필요하며, 기존의 어떠한 프로그래밍 언어들도 이것을 만족하지 못한다. 사실, 기존 언어들은 우리가 프로그램을 생각하는 것에 불필요한 혼란을 준다.
20년동안 프로그래밍 언어들은 현재 상태의 비대함으로 급격한 진보를 이루었다. 그 결과로, 프로그래밍 언어의 개발과 연구는 그 흥미를 잃었다. 대신, 이건 이제 새 생각과 씨름하는 사람들이 아닌 디테일로 가득한 두꺼운 설명서를 가지고 일을 하는 사람들의 영역이 되었다. 프로그래밍 언어에 대한 토론은 기능적으로 다른 개념들간의 흥미로운 경연이 아니라 머리의 핀에 몇명의 천사들이 춤출 수 있는지에 대해 논하는 중세 토론을 연상케 한다.
많은 창의적인 컴퓨터 과학자들은 언어를 만드는 것에서 설명하기 위한 도구들을 만드는 것으로 퇴보했다. Dana Scott이 개발한 우아한 도구를 사용하여 기존 언어의 소름 끼치는 타입 구조를 조사한 후에, 많은 사람들이 열정적으로 새로운 것들을 찾는 것이 아니라 수동적으로 지금의 구조에 머무른다는 것에 놀랐다.
이 글의 목적은 두 가지이다. 첫 번째는 기존의 언어들의 기본적인 약점들로 제안하여 그들의 표현력의 약함과 암적인 성장이 불가피함을 밝히고, 두 번째는 새로운 종류의 언어로 향하는 몇몇 대안의 길들을 제안하는 것이다.

## 2. 컴퓨터 시스템의 모델들

모든 프로그래밍 언어들의 기반에는 그 프로그램들을 제어하는 컴퓨터 시스템의 모델이 있다. 몇 모델들은 순수한 추상이고, 몇몇은 하드웨어를 나타내고, 나머지는 컴파일되거나 인터프리팅되는 프로그램들이다. 기성 언어들을 더 조사하기 전에, 현재 대안들의 세계로의 개요로써 기존의 모델들에 대한 간단한 조사를 하는 것이 유용하다. 존재하는 모델들은 대략적으로 아래에 설명된 기준에 따라 분류될 수 있다.

### 모델의 기준

1. 기초
   모델에 대한 우아하고 간결한 수학적 설명이 있는가? 그것이 모델의 동작을 증명하는데 유용한 사실인가? 혹은 모델이 너무 복잡해서 설명이 비대하고 수학적으로 거의 사용되지 않는가?
2. 이력 민감성
   모델에 다음 프로그램에 영향을 줄 수 있도록 저장소에 관한 개념이 포함되어 있는가? 이는 즉, 모델이 이력에 민감한가?
3. 의미론의 종류
   프로그램이 종료 상태에 도다를 때까지 성공적으로 상태를 변환하는가? 상태가 간단한가 혹은 복잡한가? 혹은 프로그램을 더 간단한 프로그램으로 연속적으로 축소시켜 최종적인 결과물인 정규 형식 프로그램을 생성할 수 있는가?
4. 프로그램의 명료성과 개념적 유용성
   프로그램의 모델이 연산 혹은 절차의 명료한 표현인가? 그들이 프로세스을 설명하거나 구성하는 데에 도움이 되는 개념들을 내장하고 있는가?

### 모델의 분류
위의 기준들을 이용하여 우리는 간단하게 컴퓨터 모델을 다음의 세 분류로 특정할 수 있습니다.
1. 간단한 연산 모델
   예시: 튜링 머신, 다양한 오토마타.
   기초: 간결하고 유용하다
   이력 민감성: 저장소를 가짐. 고로 이력 민감성을 띔
   의미론: 매우 간단한 상태를 이용한 상태 전환
   프로그램 명료성: 명확하지 않으며 개념적으로 도움이 되지 않음
2. 적용가능한 모델
   예시: 처치의 람다 대수, 커리의 조합자 시스템, 순수 Lisp, 본 논문에서 설명하는 함수형 프로그래밍 언어
   기초: 간결하고 유용하다
   이력 민감성: 저장소를 가지지 않음.
   의미론: 감쇠 의미론을 가짐. 상태를 가지지 않음
   프로그램 명료성: 프고그램은 명료해질 수 있고, 개념적으로 유용하다.
3. 폰 노이만 모델
   예시: 폰 노이만 컴퓨터, 기성 프로그래밍 언어들.
   기초: 복잡하고, 덩치가 크며, 유용하지 않음.
   이력 민감성: 저장소를 가지고, 이력 민감성을 띔.
   의미론: 매우 복잡한 상태를 이용한 상태 변환
   프로그램 명료성: 프로그램은 중간 정도로 명료해질 수 있으며, 개념적으로 매우 도움이 되지 않음

위의 분류는 매우 간단하게 나눈 것이며, 논쟁의 여지가 있을 수 있다. 몇 최근 모델들은 위의 분류의 카테고리에 딱 맞게 떨어지지 않을 수도 있다. 예를 들어 Arvind 와 Gostelow, Denis, Kosinski 그리고 다른 사람들이 만든 데이터-흐름 언어들은 간단 연산 모델들에 일부 맞을 수 있으나, 그들의 프로그램은 그보다는 더 명료하고, 몇몇이 감쇠 의미론을 가진다는 것에서 논란이 있을 수 있다. 어떤 경우에서든, 이 분류는 우리가 논의할 영역에서 개략적인 분류가 될 것이다. 우리는 폰 노이만 모델과 적용가능한 모델에 대해서만 고려할 것이다.

## 폰 노이만 컴퓨터들

기존 프로그래밍 언어들의 문제점을 이해하기 위해, 우리는 먼저 그들의 지적 부모인 폰 노이만 컴퓨터를 분석해야 한다. 폰 노이만 컴퓨터가 무엇인가? 30년 전에 폰 노이만 구조와 다른 것들이 태어났을 때, 폰 노이만 구조는 우아하고, 실용적이고, 그 당시에 존재했던 다수의 공학적, 프로그래밍 문제들을 통합하는 개념이었다. 비록 아키텍쳐를 생성하는 조건들이 급속도로 변하긴 했지만, 우리는 그럼에도 불구하고 여전히 30년전의 오래된 개념을 통해 컴퓨터라는 것을 인지한다. 
 가장 간단한 형태로써의 폰 노이만 컴퓨터는 3개의 부품으로 구성된다.
 1. 중앙 처리 장치
 2. 저장장치
 3. 중앙처리장치와 저장장치를 연결하는 관(tube)
저자는 이 관을 폰 노이만 병목으로 부르길 제안한다. 프로그램의 일은 저장소에 위치한 내용물을 대중적인 방법으로 바꾸는 것이다. 이는 이 일을 고려할 때에 폰 노이만 병목을 통해 하나의 단어를 왕복시키는 것이다.
 역설적이게도, 병목의 대다수를 차지하는 교통은 유용한 데이터가 데이터의 이름들, 그리고 연산들과 그 이름들을 연산하기 위한 데이터들이다. 단어가 관을 통해 이동되기 전에, 단어의 주소가 cpu에 있어야 한다. 이는 관을 통해서 저장소로부터 받던가, 어떤 연산을 통해 얻어지는 형태이든 상관없다. 만약 주소가 저장소에서 보내졌다면, 그 주소 또한 저장소에서 보내지거나, 연산을 통해 얻어져야 한다. 반대로, 만약 주소가 CPU에서 생성되었다면 이는 반드시 고정된 규칙이나 관을 통해 전달받은 명령어를 통해 처리되어야 한다. 그 명령어의 주소 또한 전자의 경우와 같다.
  물론 폰 노이만 병목을 통해 방대한 수의 단어들을 밀어넣는 것 말고도 큰 변화를 만드는 덜 원시적인 방법이 있다. 이 병목은 문자 그대로 데이터 흐름이나 문제의 병목일 뿐만 아니라, 우리가 직면한 더 큰 개념적 단위의 관점에서 생각하도록 생각하는 대신 단어별 사고에 묶인 지적인 병목현상을 야기한다. 따라서 프로그래밍은 기본적으로 폰 노이만 병목으로의 거대한 단어의 교통을 계획하고 세부화하며, 그 중 대부분의 교통은 중요한 데이터가 아니라 어디서 찾아야 하는지에 대한 것이다.

## 폰 노이만 언어들

기성 프로그래밍 언어들은 기본적으로 폰 노이만 컴퓨터의 고차원의, 복잡한 버전이다. 오직 한 종류의 컴퓨터만이 존재한다는 30년간의 믿음은, 프로그래밍 언어의 종류는 단 하나, 즉 폰 노이만 언어라는 믿음의 초석이다. 포트란과 알골64의 차이는 상당하지만, 둘 다 폰 노이만 컴퓨터의 프로그래밍 스타일을 기반으로 한다는 사실보다 덜 중요하다. 비록 저자가 기성 언어들의 스타일과 기원을 폰 노이만 언어라 칭하지만, 그들의 복잡성을 이룬 위대한 수학자들을 비난하지는 않는다. 사실, 어떤 사람들은 그 문제에 대해 내가 어느 정도 책임을 져야 한다고 말할 수도 있을 것이다.

폰 노이만 프로그래밍 언어들은 컴퓨터의 저장 공간을 모사하기 위해 변수를 사용한다. 조건문들은 명령어를 평가하고 정교하게 점프를 한다. 그리고 배정문은 패치, 저장, 그리고 수식은 모사한다. 배정문은 폰 노이만 프로그래밍 언어들의 병목이고 컴퓨터의 병목이 그렇듯 우리를 한번에 한 단어 단위로밖에 사고하지 못하게 한다.

일반적인 프로그램을 생각해볼때, 그 중심에는 첨자 변수들을 포함한 여러 할당문들이 존재한다. 매 배정문은 한 단어의 결과를 생성한다. 프로그램은 한번에 한 단어씩 수행되어야 하기 때문에 전체 변경을 만들기 위해서는 변수들을 변경하면서 이런 명령문을 여러 번 실행해야 한다. 프로그래머는 불필요한 반복을 유발하는 조건문의 중첩을 설계하기 때문에 배정 병목을 따라 흐르는 단어들을 고려해야 한다.

더욱이, 배정문은 프로그래밍을 두 세계로 분리한다. 첫 세계는 배정문의 옳은 면을 구성합니다. 이는 질서정연한 표현의 세계이고 유용한 대수적 속성을 가진 세계입니다. 이는 대부분의 유용한 연산들이 위치한 곳입니다.
  
기성 프로그래밍 언어의 두 번째 세계는 구문의 세계입니다. 그 세계의 주 구문은 배정문 그 자체입니다. 언어에 존재하는 나머지 모든 구문들은 가장 원초적인 구조인 배정문을 가능하게 하기 위해 존재합니다.

이 문의 세계는 몇 유용한 수학적인 속성들만을 가진 무질서한 것입니다. 구조적 프로그래밍은 이 무질서한 세계에 몇 질서를 가져온 겸손한 노력처럼 보이지만, 이는 원초적인 반복문의 사용, 서브스크립트, 그리고 분기흐름의 제어문을 이용하여 한번에 하나의 단어를 이해하는 폰 노이만 프로그래밍의 세계에 의해 생성된 근본적인 문제를 공격하는 데에 거의 성과가 없다.

폰 노이만 언어들에 대한 우리의 집착들은 폰 노이만 컴퓨터의 우위로 이어졌고, 폰 노이만 언어들에 대한 의존성은 폰 노이만 언어가 아닌 언어들을 비경제적이고, 개발을 제한하도록 하였습니다. 폰 노이만 언어가 아닌 원칙에 기반한 완전한 규모의 효과적인 프로그래밍 스타일이 없기 때문에 설계자는 새로운 컴퓨터 아키텍처를 위한 지적 기반을 박탈했습니다.

적용형 컴퓨터 시스템의 이력 민감성과 저장공간의 부재는 그들이 컴퓨터 디자인의 기틀을 제공하지 못한 주요 원인입니다. 더욱이, 가장 적용적인 