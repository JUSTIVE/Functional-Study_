# 람다 대수 Lambda Calculus
[reference](https://www.sangkon.com/haskell-study-part02/)  
- 1930년도 알론조 처치`Alonzo Church`가 발표한 계산 모델  
- 결정 문제`decision problem`를 해결
- 계산 가능성`computability` 혹은 계산 가능한 함수`computable function`의 정의
- 함수형 언어의 계산 모델

힐베르트`David Hilbert`에 의해 명제->참/거짓 의 알고리즘을 연구  
괴델에`Kurt Godel` 의해 위의 알고리즘은 존재하지 않고, 존재할 수 없음을 불완전성 정리`imcompleteness Theorem` 으로 증명  
불완정성 정리에서는 모든 수학적인 논리 체계 하에서는 논리 자체적으로 증명할 수 없는 문제가 존재함을 나타냄.  
따라서 많은 사람들은 풀 수 있는 문제에 연구를 수행

- 클레이너`Kleene Star`->알론조 처치`Alonzo Church`:Recursive function
- 알론조 처치`Alonzo Church`:Lambda Calculus
- 에밀 레온 포스트`Emil Leon Post`:Post Canonical Systems
- 앨런 튜링`Alan Turing`:튜링 기계

이후 1937년도에 튜링과 처치가 독자적인 연구를 바탕으로 모든 계산 가능한 연산은 처치의 방법을 쓸 수 있고, 이 역도 성립함이 증명됨.  
이는 람다 대수는 임의의 튜링 기계`Turing Machine`을 시뮬레이션 할 수 있는 보편적인 계산 모델로서, 튜링 완전`Turing Complete` 함을 의미하고, 계산 가능성 이론`Computability Theory`가 객관적이고 수학적인 특성을 가짐을 의미

>튜링 기계`Turing Machine`  
>[reference](https://en.wikipedia.org/wiki/Turing_machine#:~:text=A%20Turing%20machine%20is%20a,algorithm's%20logic%20can%20be%20constructed.)  
>- 수학적 모형으로, 특수한 테이프를 이용하여 동작하는 기계
>- 유한한 개수의 기초적 지시문으로 이루어진 테이프
>- `On computable numbers, with an application to the Entscheidungsproblem`
>
>호프크로프트`Hopcroft`와 울만`Ullman`은 단일 테이프 튜링 기계를 M = <Q,Γ,b,Σ,δ,q_0,F>로 정의  
>|기호|의미|
>|---|---|
>|Q|유한하고 비어있지 않은 상태들의 집합|
>|Γ|유한하고 비어있지 않은 기호와 알파벳들의 집합|
>|b∈Γ|비어있음을 알려주는 기호(테이프 위에서 유일하게 무한하게 나타날 수 있는 기호)|
>|q_0∈Q|초기 상태|
>|F⊆Q|최종 상태, 혹은 수락 상태
>|δ|Q/F×Γ→Q×Γ×{L,R} (부분함수)
>위의 정의를 바탕으로 작동하는 모든 것은 튜링 기계로 불림

>튜링 완전`Turing Complete`  
>[reference](https://ko.wikipedia.org/wiki/%ED%8A%9C%EB%A7%81_%EC%99%84%EC%A0%84)  
>어떤 프로그래밍 언어나 추상 기계가 튜링 기계와 동일한 계산 능력을 가진다는 의미.
>제한 없는 기억장치를 포함한 장치는 물리적으로 불가능하므로, 기억 장치가 늘어난다는 가정 하에 `느슨한 튜링 완전`으로 간주한다.

>계산 가능성 이론`Computability Theory`

## 함수의 표현

항등 함수 
```math
I(x)=x
```

- 함수는 이름을 가질 필요는 없다: 위의 항등 함수`I(x) = x`는 `x → x`의 형태로 쓸 수 있다.
- 함수의 입력 변수의 이름도 필요 없다.`x → x`는 `y → y` 와 같다
- 두 개 이상의 입력을 받는 함수는 하나의 입력을 받아 또 다른 함수를 출력하는 형태로 다시 쓸 수 있다.`커링`
  - ex) `(x,y) → x * x + y * y`에 대해서
  - x → (y → x * x + y * y)(5)(2)
  - = (y → 5 * 5 + y * y)(2)

## 람다 대수
람다 대수는 특정 형식 언어이며 람다 용어의 변형을 가능하게 하는 변형 규칙 집합인 람다 용어로 구성되어 있다. 이러한 변형 규칙은 보편 대수학 혹은 조작적 정의로 볼 수 있다.

람다 대수의 모든 함수는 익명이며, 하나의 입력 변수만 허용하고, 커링을 통해 여러 변수를 받는 함수를 구현한다.

### 람다 용어`lambda terms`
람다 대수의 문법은 어떤 문자열들이 유효한 C 프로그램인지 아닌지를 나타내듯 어떤 표현들이 유효한 람다 대수 표현인지 아닌지를 정의한다. 유효한 람다 대수 표현은 람다 용어`lambda terms`라고 한다.

다음의 세 규칙은 문법적으로 유효한 모든 람다 용어를 만들 수 있는 귀납적 정의를 제시한다.
1. 변수 x는 그 자체로 유효한 람다 용어이다.
2. 만약 t가 람다 용어이고, x가 변수라면, `(λx.t)`는 람다 용어이다(추상화라 불린다)
3. 만약 t와 s가 람다 용어이면, `(ts)`는 람다 용어이다(적용이라 불린다)

이외의 어떤 것도 람다 용어가 아니다. 따라서 람다 용어는 위의 세 규칙을 반복해서 적용하여 얻을 수 있는 경우에만 유효하다. 그러나, 몇 괄호들은 특정 규칙에 따라 사라질 수도 있다. 예를 들어, 최외각에 위치한 괄호는 보통 쓰지 않는다.

추상 `λx.t` 은 단일 입력 x를 받아 표현 t를 도출할 수 있는 익명 함수의 정의이다. 예를 들어, `λx.x^2 + 2`는 `x^2 + 2`를 t로 사용하는 함수`f(x) = x^2 + 2`의 추상화이다. 함수를 정의하는 것은 함수를 준비하기만 하며 호출하지는 않는다. 이 추상은 x는 용어 t에 바인딩힌다.

적용 `ts`는 입력 s를 함수 t에 적용하는 것을 표현한 것이며, 함수 t에 입력 s를 넣은 상태로 호출한 `t(s)`를 의미한다.

람다 대수에서는 변수 선언 개념은 없습니다. `λx.x+y`와 같은 정의에서, 람다 대수는 y를 정의되지 않은 변수로 취급한다. 추상 `λx.x+y`은 문법적으로 유효하며, 입력된 값에 아직 알려지지 않은 y를 더하는 것을 표현한다. 괄호는 애매함을 제거하기 위해 사용하거나 사용되어야 한다. 예를 들어 λx.((λx.x)x)와 (λx.(λx.x))x은 다른 용어를 의미한다. 

### 함수들에서 동작하는 함수들
람다 대수에서, 함수는 `1급 값, first class value`으로 취급된다. 따라서 함수는 다른 함수들의 입력값 혹은 반환값으로 사용될 수도 있다.

예를 들어,λx.x는 x→x인 항등 함수를 나타내고, (λx.x)y 는 항등 함수에 y를 적용한 것을 나타낸다. (λx.y)는 입력 값에 상관없이 언제나 y를 반환하는 상수 함수 x→y를 나타낸다. 람다 대수에서, 함수 적용은 왼쪽 연관으로 간주됩니다. 따라서 stx는 (st)x를 의미합니다.

람다 용어를 동등하게 줄일 수 있는 "동등" 과 "축약" 기호들이 몇 있습니다. 

### 알파 동치alpha equivalence
동등의 기본 형태로, 람다 용어에서 정의할 수 있는 것은 알파 동등합니다.  
[reference](https://lucasfcosta.com/2018/08/05/An-Introduction-to-Lambda-Calculus-Part-2.html)  
알파 동등은 바운드 변수의 이름만 다를 때를 의미합니다. 예를 들어 다음의 두 함수는 알파 동등합니다

```
fn1 = λx. λy. x(y)
fn2 = λa. λb. a(b)
```
레이맨의 용어에 따르면, 두 함수는 같은 역할을 할 때 알파 도응하다고 한다. 만약 모든 fn1를 fn2로 바꿨을 때, 프로그램은 같은 역할을 수행할 것이다.

다른 이름들의 변수들이 모두 바인딩되어있기 때문에 두 함수가 알파 동등이라고 강조하는 것은 중요하다. 만약 변수들 중 하나라도 바운드되지 않았다면, 다른 동작을 할 것이기 때문에 두 함수는 알파 동등하지 않다.

```
fn1 = λx. λy. x(y(z))
fn2 = λx. λy. λz. x(y(z))
// 이 둘은 α-동등이 아니다
```

위 두 함수가 함수 몸체가 같음에도 알파 동등이 아닌 이유는, fn1의 변수 z는 자유이고, fn2의 변수 z는 바운딩 되어있기 때문이다. 다음은 추가적인 예시이다.

- `λx. x y` 와 `λa. a y` 이 둘은 알파 동등이다. 바운딩 되어있는 변수 `x`의 이름만 바뀐 것이다. `y`는 자유 변수이고, 이름이 달라지지 않았다.
- `λx. x y` 와 `λx. x z` 이 둘은 알파 동등이 아니다. 첫 번째 함수의 `y`는 두 번째 함수의 자유 변수인 `z`와 같지 않다.
- `λx. λy. y x` 와 `λx. λy. x y` 는 알파 동등이 아니다.
- `λx. λx. x` 와 `λy. λx. x`는 알파 동등이다. 이는 내부 함수의 `x` 가 내부의 메타 변수 `x`에 바운딩되고, 최외각 메타변수는 완전히 다른 변수이기 때문이다.

### 자유 변수free variables

자유 변수는 추상화에 바운딩되지 않은 변수들을 지칭하는 용어이다. 표현식의 자유 변수 집합은 귀납적으로 정의됩니다.
- 자유 변수의 x는 x이다
- λx.t의 자유 변수 집합은 x가 지워진 t의 자유 변수의 집합이다
- ts의 자유 변수 집합은 t의 자유 변수 집합과 s의 자유 변수 집합의 합집합이다.

예를 들어, 항등 함수 λx.x는 자유 변수가 없으나, λx. yx는 하나의 자유 변수 y를 가진다.
